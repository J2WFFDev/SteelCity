#!/usr/bin/env python3
"""
AMG Commander – Start Timer (Bleak 1.x clean version with fixed parser)
"""

import argparse
import asyncio
import csv
import datetime as dt
import os
import sys
from dataclasses import dataclass
from typing import Optional, Callable

# ---------- Timer core -------------------------------------------------------

@dataclass
class TimerState:
    running: bool = False
    start_ts: Optional[float] = None
    elapsed: float = 0.0
    target: Optional[float] = None

    def now(self) -> float:
        return asyncio.get_event_loop().time()

    def start(self, target: Optional[float] = None) -> None:
        if self.running:
            return
        self.start_ts = self.now()
        self.running = True
        self.target = target

    def stop(self) -> None:
        if not self.running:
            return
        self.elapsed += self.now() - (self.start_ts or self.now())
        self.running = False
        self.start_ts = None

    def reset(self) -> None:
        self.running = False
        self.start_ts = None
        self.elapsed = 0.0
        self.target = None

    def seconds(self) -> float:
        if self.running and self.start_ts is not None:
            return self.elapsed + (self.now() - self.start_ts)
        return self.elapsed

    def remaining(self) -> Optional[float]:
        if self.target is None:
            return None
        return max(0.0, self.target - self.seconds())

    def is_done(self) -> bool:
        r = self.remaining()
        return r is not None and r <= 0.0


# ---------- CSV logger -------------------------------------------------------

class CsvLogger:
    def __init__(self, path: str):
        self.path = path
        self._file = open(self.path, "a", newline="")
        self._w = csv.writer(self._file)
        if os.stat(self.path).st_size == 0:
            self._w.writerow(["utc_iso", "event", "elapsed_s", "remaining_s"])

    def log(self, event: str, elapsed: float, remaining: Optional[float]):
        self._w.writerow([
            dt.datetime.utcnow().isoformat(timespec="seconds") + "Z",
            event,
            f"{elapsed:.3f}",
            "" if remaining is None else f"{remaining:.3f}",
        ])
        self._file.flush()

    def close(self):
        try:
            self._file.close()
        except Exception:
            pass


# ---------- Control channels -------------------------------------------------

class ControlChannel:
    async def run(self, on_bytes: Callable[[bytes], None]):
        raise NotImplementedError

class MockControl(ControlChannel):
    async def run(self, on_bytes: Callable[[bytes], None]):
        print("[mock] Type commands: START [secs], STOP, RESET. Ctrl+C to exit.")
        loop = asyncio.get_event_loop()
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda: protocol, sys.stdin)
        while True:
            line = await reader.readline()
            if not line:
                await asyncio.sleep(0.05)
                continue
            on_bytes(line.strip())

class BleControl(ControlChannel):
    def __init__(self, adapter: str, mac: Optional[str], name: Optional[str], ctl_uuid: str):
        self.adapter = adapter
        self.mac = mac
        self.name = name
        self.ctl_uuid = ctl_uuid

    async def run(self, on_bytes: Callable[[bytes], None]):
        from bleak import BleakClient, BleakScanner

        device = None
        if self.mac:
            device = await BleakScanner.find_device_by_address(self.mac, cb=dict(use_bdaddr=False))
        else:
            print(f"[scan] Looking for name contains: {self.name!r} (adapter={self.adapter})")
            found = await BleakScanner.discover(adapter=self.adapter, timeout=8.0)
            for d in found:
                if self.name and self.name.lower() in (d.name or "").lower():
                    device = d
                    break
        if not device:
            raise RuntimeError("AMG device not found.")

        print(f"[ble] Connecting to {device.address} ({device.name}) …")
        async with BleakClient(device, timeout=20.0, device=self.adapter) as client:
            svcs = client.services or []
            try:
                seen = {str(c.uuid).lower() for s in svcs for c in s.characteristics}
            except Exception:
                seen = set()
            if self.ctl_uuid.lower() not in seen:
                print("[warn] Control UUID not in index; subscribing anyway…")

            async def _cb(_, data: bytearray):
                on_bytes(bytes(data))

            print(f"[ble] Subscribing to control char {self.ctl_uuid}")
            await client.start_notify(self.ctl_uuid, _cb)
            print("[ble] Ready. Waiting for commands… (Ctrl+C to exit)")
            while True:
                await asyncio.sleep(3600)


# ---------- Commander --------------------------------------------------------

@dataclass
class CommanderConfig:
    adapter: str = "hci0"
    mac: Optional[str] = None
    name: Optional[str] = "AMG"
    ctl_uuid: str = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"
    log_csv: Optional[str] = None
    tick_hz: float = 4.0


class Commander:
    def __init__(self, cfg: CommanderConfig):
        self.cfg = cfg
        self.timer = TimerState()
        self.logger = CsvLogger(cfg.log_csv) if cfg.log_csv else None
        self._tick_task: Optional[asyncio.Task] = None

    async def run(self, control: ControlChannel):
        self._tick_task = asyncio.create_task(self._ticker())
        try:
            await control.run(self._on_control)
        finally:
            if self._tick_task:
                self._tick_task.cancel()
            if self.logger:
                self.logger.close()

    def _on_control(self, payload: bytes):
        """Parse incoming bytes into commands."""
        # Heuristic for AMG 14‑byte frames
        if payload and len(payload) >= 14 and payload[0] == 0x01:
            import struct
            secs = struct.unpack_from("<I", payload, 1)[0]
            tail = payload[5:-1]
            if all(b == 0x00 for b in tail) and 0 < secs <= 3600:
                self._apply_cmd("START", float(secs))
                return

        # Generic binary 0x01/0x02/0x03
        if payload:
            b0 = payload[0]
            if b0 in (1, 2, 3):
                dur = None
                if b0 == 1 and len(payload) >= 5:
                    import struct
                    dur = float(struct.unpack_from("<I", payload, 1)[0])
                if dur is None or 0 <= dur <= 3600:
                    self._apply_cmd({1: "START", 2: "STOP", 3: "RESET"}[b0], dur)
                    return

        # Textual commands
        try:
            txt = payload.decode("utf-8", errors="ignore").strip()
        except Exception:
            txt = ""
        if txt:
            parts = txt.split()
            cmd = parts[0].upper()
            dur = None
            if cmd == "START" and len(parts) > 1:
                try:
                    dur = float(parts[1])
                except ValueError:
                    dur = None
            if cmd in ("START", "STOP", "RESET"):
                self._apply_cmd(cmd, dur)
                return

        # Else ignore
        if getattr(self.cfg, "debug_hex", False):
            preview = payload.hex()
            if len(preview) > 64:
                preview = preview[:64] + "…"
            print(f"[ctl] Ignored payload: len={len(payload)} hex={preview}")

    def _apply_cmd(self, cmd: str, dur: Optional[float]):
        if cmd == "START":
            self.timer.reset()
            self.timer.start(dur)
            self._emit("start")
        elif cmd == "STOP":
            self.timer.stop()
            self._emit("stop")
        elif cmd == "RESET":
            self.timer.reset()
            self._emit("reset")

    async def _ticker(self):
        period = 1.0 / max(1e-3, self.cfg.tick_hz)
        try:
            while True:
                await asyncio.sleep(period)
                if self.timer.running and self.timer.is_done():
                    self.timer.stop()
                    self._emit("done")
                else:
                    self._emit("tick")
        except asyncio.CancelledError:
            pass

    def _emit(self, event: str):
        elapsed = self.timer.seconds()
        remaining = self.timer.remaining()
        if event == "tick":
            rem = "∞" if remaining is None else f"{remaining:6.1f}s"
            print(f"\r[timer] {('RUN' if self.timer.running else 'PAUSE')}  t={elapsed:7.2f}s  rem={rem} ", end="", flush=True)
            return
        print()
        print(f"[event] {event.upper():5s} | elapsed={elapsed:.3f}s | remaining={(remaining if remaining is not None else '∞')}")
        if self.logger:
            self.logger.log(event, elapsed, remaining)


# ---------- CLI --------------------------------------------------------------

def parse_args():
    p = argparse.ArgumentParser()
    src = p.add_mutually_exclusive_group()
    src.add_argument("--mac")
    src.add_argument("--name", default="AMG")
    p.add_argument("--adapter", default="hci0")
    p.add_argument("--ctl", dest="ctl_uuid", default="6e400003-b5a3-f393-e0a9-e50e24dcca9e")
    p.add_argument("--csv", dest="log_csv")
    p.add_argument("--tick", dest="tick_hz", type=float, default=4.0)
    p.add_argument("--debug-hex", action="store_true", help="Print ignored frame hex for debugging")
    p.add_argument("--mock", action="store_true")
    args = p.parse_args()
    cfg = CommanderConfig(
        adapter=args.adapter,
        mac=args.mac,
        name=None if args.mac else args.name,
        ctl_uuid=args.ctl_uuid,
        log_csv=args.log_csv,
        tick_hz=args.tick_hz,
    )
    # stash debug flag on the cfg object dynamically
    setattr(cfg, "debug_hex", args.debug_hex)
    return cfg, args.mock

async def main():
    cfg, mock = parse_args()
    commander = Commander(cfg)
    control: ControlChannel = MockControl() if mock else BleControl(cfg.adapter, cfg.mac, cfg.name, cfg.ctl_uuid)
    await commander.run(control)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
    except SystemExit:
        pass
