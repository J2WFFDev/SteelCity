#!/usr/bin/env python3
"""
AMG Commander – Start/Stop Timer with AMG-specific binary frame parsing (Bleak 1.x friendly)
- START: 14-byte frame, b[0]==0x01, LE32 secs at b[1..4], middle zeros, tail flag -> 0x01
- STOP:  tail flag transition -> 0x02, only if timer is currently running
- TRACE: optional --trace-states prints tail flag & secs for every 14-byte frame
"""

import argparse, asyncio, csv, datetime as dt, os, sys
from dataclasses import dataclass
from typing import Optional, Callable

# ---------- Timer core -------------------------------------------------------

@dataclass
class TimerState:
    running: bool = False
    start_ts: Optional[float] = None
    elapsed: float = 0.0
    target: Optional[float] = None

    def now(self) -> float:
        return asyncio.get_event_loop().time()

    def start(self, target: Optional[float] = None) -> None:
        if self.running: return
        self.start_ts = self.now()
        self.running = True
        self.target = target

    def stop(self) -> None:
        if not self.running: return
        self.elapsed += self.now() - (self.start_ts or self.now())
        self.running = False
        self.start_ts = None

    def reset(self) -> None:
        self.running = False
        self.start_ts = None
        self.elapsed = 0.0
        self.target = None

    def seconds(self) -> float:
        if self.running and self.start_ts is not None:
            return self.elapsed + (self.now() - self.start_ts)
        return self.elapsed

    def remaining(self) -> Optional[float]:
        if self.target is None: return None
        return max(0.0, self.target - self.seconds())

    def is_done(self) -> bool:
        r = self.remaining()
        return r is not None and r <= 0.0


# ---------- CSV logger -------------------------------------------------------

class CsvLogger:
    def __init__(self, path: str):
        self.path = path
        self._file = open(self.path, "a", newline="")
        self._w = csv.writer(self._file)
        if os.stat(self.path).st_size == 0:
            self._w.writerow(["utc_iso", "event", "elapsed_s", "remaining_s"])

    def log(self, event: str, elapsed: float, remaining: Optional[float]):
        self._w.writerow([
            dt.datetime.utcnow().isoformat(timespec="seconds") + "Z",
            event,
            f"{elapsed:.3f}",
            "" if remaining is None else f"{remaining:.3f}",
        ])
        self._file.flush()

    def close(self):
        try: self._file.close()
        except Exception: pass


# ---------- Control channels -------------------------------------------------

class ControlChannel:
    async def run(self, on_bytes: Callable[[bytes], None]):
        raise NotImplementedError

class MockControl(ControlChannel):
    async def run(self, on_bytes: Callable[[bytes], None]):
        print("[mock] Type commands: START [secs], STOP, RESET. Ctrl+C to exit.")
        loop = asyncio.get_event_loop()
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda: protocol, sys.stdin)
        while True:
            line = await reader.readline()
            if not line:
                await asyncio.sleep(0.05); continue
            on_bytes(line.strip())

class BleControl(ControlChannel):
    def __init__(self, adapter: str, mac: Optional[str], name: Optional[str], ctl_uuid: str):
        self.adapter, self.mac, self.name, self.ctl_uuid = adapter, mac, name, ctl_uuid

    async def run(self, on_bytes: Callable[[bytes], None]):
        from bleak import BleakClient, BleakScanner
        device = None
        if self.mac:
            device = await BleakScanner.find_device_by_address(self.mac, cb=dict(use_bdaddr=False))
        else:
            print(f"[scan] Looking for name contains: {self.name!r} (adapter={self.adapter})")
            for d in await BleakScanner.discover(adapter=self.adapter, timeout=8.0):
                if self.name and self.name.lower() in (d.name or "").lower():
                    device = d; break
        if not device:
            raise RuntimeError("AMG device not found.")

        print(f"[ble] Connecting to {device.address} ({device.name}) …")
        async with BleakClient(device, timeout=20.0, device=self.adapter) as client:
            svcs = client.services or []
            try:
                seen = {str(c.uuid).lower() for s in svcs for c in s.characteristics}
            except Exception:
                seen = set()
            if self.ctl_uuid.lower() not in seen:
                print("[warn] Control UUID not in index; subscribing anyway…")

            async def _cb(_, data: bytearray):
                on_bytes(bytes(data))

            print(f"[ble] Subscribing to control char {self.ctl_uuid}")
            await client.start_notify(self.ctl_uuid, _cb)
            print("[ble] Ready. Waiting for commands… (Ctrl+C to exit)")
            while True:
                await asyncio.sleep(3600)


# ---------- Commander --------------------------------------------------------

@dataclass
class CommanderConfig:
    adapter: str = "hci0"
    mac: Optional[str] = None
    name: Optional[str] = "AMG"
    ctl_uuid: str = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"
    log_csv: Optional[str] = None
    tick_hz: float = 4.0

class Commander:
    def __init__(self, cfg: CommanderConfig):
        self.cfg = cfg
        self.timer = TimerState()
        self.logger = CsvLogger(cfg.log_csv) if cfg.log_csv else None
        self._tick_task: Optional[asyncio.Task] = None
        self._last_tail_flag: Optional[int] = None   # last seen tail flag (0x01/0x02/…)
        self._max_secs = getattr(cfg, "max_secs", 3600)
        self._log_ticks = getattr(cfg, "log_ticks", False)
        self._trace_states = getattr(cfg, "trace_states", False)

    async def run(self, control: ControlChannel):
        self._tick_task = asyncio.create_task(self._ticker())
        try:
            await control.run(self._on_control)
        finally:
            if self._tick_task: self._tick_task.cancel()
            if self.logger: self.logger.close()

    def _on_control(self, payload: bytes):
        """Parse incoming control bytes → timer commands."""
        # AMG 14-byte binary frames over Nordic UART
        if payload and len(payload) == 14 and payload[0] == 0x01:
            import struct
            secs = struct.unpack_from("<I", payload, 1)[0]  # bytes 1..4
            mid  = payload[5:-1]                            # bytes 5..12
            tail = payload[-1]                              # byte 13

            if self._trace_states:
                mid_zero = all(b == 0x00 for b in mid)
                print(f"[state] tail=0x{tail:02x} secs={secs} mid_zero={mid_zero} hex={payload.hex()}")

            prev = self._last_tail_flag
            self._last_tail_flag = tail  # update after reading

            # START: sane secs, zero middle, tail transition to 0x01
            if (prev is not None and prev != 0x01 and tail == 0x01 and
                0 < secs <= self._max_secs and all(b == 0x00 for b in mid)):
                self._apply_cmd("START", float(secs))
                return

            # STOP: tail transition to 0x02, only if timer is running
            if (prev is not None and prev != 0x02 and tail == 0x02 and self.timer.running):
                self._apply_cmd("STOP", None)
                return

        # Minimal generic binary (0x01/0x02/0x03 + optional LE32 secs)
        if payload:
            b0 = payload[0]
            if b0 in (1, 2, 3):
                dur = None
                if b0 == 1 and len(payload) >= 5:
                    import struct
                    dur = float(struct.unpack_from("<I", payload, 1)[0])
                if dur is None or 0 <= dur <= self._max_secs:
                    if b0 != 2 or self.timer.running:
                        self._apply_cmd({1:"START",2:"STOP",3:"RESET"}[b0], dur)
                        return

        # Text fallback
        try:
            txt = payload.decode("utf-8", errors="ignore").strip()
        except Exception:
            txt = ""
        if txt:
            parts = txt.split()
            cmd = parts[0].upper()
            dur = None
            if cmd == "START" and len(parts) > 1:
                try: dur = float(parts[1])
                except ValueError: dur = None
            if cmd in ("START","STOP","RESET"):
                if cmd != "STOP" or self.timer.running:
                    self._apply_cmd(cmd, dur)
                    return

        if getattr(self.cfg, "debug_hex", False):
            hx = payload.hex()
            print(f"\n[ctl] Ignored payload: len={len(payload)} hex={hx[:64]+('…' if len(hx)>64 else '')}")

    def _apply_cmd(self, cmd: str, dur: Optional[float]):
        if cmd == "START":
            self.timer.reset()
            self.timer.start(dur)
            self._emit("start")
        elif cmd == "STOP":
            self.timer.stop()
            self._emit("stop")
        elif cmd == "RESET":
            self.timer.reset()
            self._emit("reset")

    async def _ticker(self):
        period = 1.0 / max(1e-3, self.cfg.tick_hz)
        try:
            while True:
                await asyncio.sleep(period)
                if self.timer.running and self.timer.is_done():
                    self.timer.stop()
                    self._emit("done")
                else:
                    self._emit("tick")
        except asyncio.CancelledError:
            pass

    def _emit(self, event: str):
        elapsed = self.timer.seconds()
        remaining = self.timer.remaining()
        if event == "tick":
            rem = "∞" if remaining is None else f"{remaining:6.1f}s"
            print(f"\r[timer] {('RUN' if self.timer.running else 'PAUSE')}  t={elapsed:7.2f}s  rem={rem} ", end="", flush=True)
            if self._log_ticks and self.logger:
                self.logger.log("tick", elapsed, remaining)
            return
        print()
        print(f"[event] {event.upper():5s} | elapsed={elapsed:.3f}s | remaining={(remaining if remaining is not None else '∞')}")
        if self.logger:
            self.logger.log(event, elapsed, remaining)


# ---------- CLI --------------------------------------------------------------

def parse_args():
    p = argparse.ArgumentParser()
    src = p.add_mutually_exclusive_group()
    src.add_argument("--mac")
    src.add_argument("--name", default="AMG")
    p.add_argument("--adapter", default="hci0")
    p.add_argument("--ctl", dest="ctl_uuid", default="6e400003-b5a3-f393-e0a9-e50e24dcca9e")
    p.add_argument("--csv", dest="log_csv")
    p.add_argument("--tick", dest="tick_hz", type=float, default=4.0)
    p.add_argument("--mock", action="store_true")
    p.add_argument("--debug-hex", action="store_true")
    p.add_argument("--trace-states", action="store_true", help="Print tail flag & secs for every 14-byte frame")
    p.add_argument("--max-secs", type=int, default=3600)
    p.add_argument("--log-ticks", action="store_true", help="Also log 'tick' rows to CSV each update")
    args = p.parse_args()
    cfg = CommanderConfig(
        adapter=args.adapter,
        mac=args.mac,
        name=None if args.mac else args.name,
        ctl_uuid=args.ctl_uuid,
        log_csv=args.log_csv,
        tick_hz=args.tick_hz,
    )
    setattr(cfg, "debug_hex", args.debug_hex)
    setattr(cfg, "trace_states", args.trace_states)
    setattr(cfg, "max_secs", args.max_secs)
    setattr(cfg, "log_ticks", args.log_ticks)
    return cfg, args.mock

async def main():
    cfg, mock = parse_args()
    commander = Commander(cfg)
    control: ControlChannel = MockControl() if mock else BleControl(cfg.adapter, cfg.mac, cfg.name, cfg.ctl_uuid)
    await commander.run(control)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
    except SystemExit:
        pass
